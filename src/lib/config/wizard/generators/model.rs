//! Model configuration generator
//!
//! Generates and modifies config/model.toml containing:
//! - `default_provider` - Default API provider ID
//! - `model` - Default model name
//! - `[prompts]` - System prompt template and configurable prompts
//! - `[[tools]]` - Tool definitions synced from MCP servers

use crate::constants::MODEL_CONFIG_PATH;
use std::collections::HashSet;
use std::error::Error;
use std::fs;
use std::path::Path;

/// Generate the model configuration file
pub fn generate(provider_id: &str, default_model: &str) -> Result<(), Box<dyn Error>> {
    let config_content = format!(
        r#"# Model Configuration
# Generated by setup wizard

# Default provider and model
default_provider = "{provider_id}"
model = "{default_model}"

# System prompt template
prompt_template = """
You are a helpful AI assistant.

{{{{custom_instruction}}}}

{{{{language_guidance}}}}

{{{{tool_guidance}}}}
"""
"#,
        provider_id = provider_id,
        default_model = default_model,
    );

    fs::create_dir_all("config")?;
    fs::write(MODEL_CONFIG_PATH, config_content)?;

    Ok(())
}

/// Update the default provider
pub fn update_default_provider(provider_id: &str) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(MODEL_CONFIG_PATH);
    let content = fs::read_to_string(config_path)?;

    let mut result = String::new();

    for line in content.lines() {
        if line.starts_with("default_provider = ") {
            result.push_str(&format!("default_provider = \"{}\"", provider_id));
        } else {
            result.push_str(line);
        }
        result.push('\n');
    }

    fs::write(config_path, result.trim_end())?;
    Ok(())
}

/// Update the default model
pub fn update_default_model(model_name: &str) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(MODEL_CONFIG_PATH);
    let content = fs::read_to_string(config_path)?;

    let mut result = String::new();

    for line in content.lines() {
        if line.starts_with("model = ") {
            result.push_str(&format!("model = \"{}\"", model_name));
        } else {
            result.push_str(line);
        }
        result.push('\n');
    }

    fs::write(config_path, result.trim_end())?;
    Ok(())
}

/// Update the prompt template
pub fn update_prompt_template(template: &str) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(MODEL_CONFIG_PATH);
    let content = fs::read_to_string(config_path)?;
    let mut result = String::new();
    let mut in_template = false;
    let mut template_written = false;

    for line in content.lines() {
        if line.starts_with("prompt_template = ") {
            in_template = true;
            if !template_written {
                result.push_str(&format!("prompt_template = \"\"\"\n{}\n\"\"\"\n", template));
                template_written = true;
            }
            if !line.contains("\"\"\"") {
                in_template = false;
            }
            continue;
        }

        if in_template {
            if line.contains("\"\"\"") {
                in_template = false;
            }
            continue;
        }

        result.push_str(line);
        result.push('\n');
    }

    fs::write(config_path, result.trim_end())?;
    Ok(())
}

/// Sync tools from a server
/// Removes existing tools with the same names before adding new ones
pub fn sync_tools_from_server(
    server_name: &str,
    tools: Vec<(String, String)>,
) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(MODEL_CONFIG_PATH);
    let content = fs::read_to_string(config_path)?;

    // Collect tool names we're about to sync
    let syncing_names: HashSet<&str> = tools.iter().map(|(name, _)| name.as_str()).collect();

    let mut new_content = String::new();
    let mut skip_tool = false;
    let mut pending_header = false;

    for line in content.lines() {
        // Detect start of a new tool block
        if line.trim() == "[[tools]]" {
            // If we were skipping, we're done with that tool
            skip_tool = false;
            pending_header = true;
            continue; // Don't write header yet, wait to check the name
        }

        // Check if this line defines the tool name
        if pending_header {
            if let Some(name) = extract_tool_name(line) {
                // Skip this tool if it has the same name as one we're syncing
                if syncing_names.contains(name.as_str()) {
                    skip_tool = true;
                    pending_header = false;
                    continue;
                }
            }
            // Write the pending header since we're not skipping
            if !skip_tool {
                new_content.push_str("[[tools]]\n");
            }
            pending_header = false;
        }

        if !skip_tool {
            new_content.push_str(line);
            new_content.push('\n');
        }
    }

    // Add new tools from the server
    for (tool_name, description) in tools {
        let escaped_desc = description.replace('\"', "\\\"");
        let tool_block = format!(
            r#"
[[tools]]
name = "{}"
description = "{}"
server = "{}""#,
            tool_name, escaped_desc, server_name
        );
        new_content.push_str(&tool_block);
    }

    fs::write(config_path, new_content.trim_end())?;
    Ok(())
}

/// Extract tool name from a line like `name = "tool_name"`
fn extract_tool_name(line: &str) -> Option<String> {
    let trimmed = line.trim();
    if trimmed.starts_with("name = \"") && trimmed.ends_with("\"") {
        let start = "name = \"".len();
        let end = trimmed.len() - 1;
        Some(trimmed[start..end].to_string())
    } else {
        None
    }
}

//! Model configuration generator
//!
//! Generates and modifies config/model.toml containing:
//! - `default_provider` - Default API provider ID
//! - `model` - Default model name
//! - `[prompts]` - System prompt template and configurable prompts
//! - `[[tools]]` - Tool definitions synced from MCP servers

use crate::constants::MODEL_CONFIG_PATH;
use std::collections::HashSet;
use std::error::Error;
use std::fs;
use std::path::Path;

/// Generate the model configuration file with new [prompts] section format
pub fn generate(provider_id: &str, default_model: &str) -> Result<(), Box<dyn Error>> {
    let config_content = format!(
        r#"# Model Configuration
# Generated by setup wizard

# Default provider and model
default_provider = "{provider_id}"
model = "{default_model}"

# Prompts configuration
[prompts]
template = """
You are a helpful AI assistant.

{{{{custom_instruction}}}}

{{{{language_guidance}}}}

{{{{tool_guidance}}}}
"""
"#,
        provider_id = provider_id,
        default_model = default_model,
    );

    fs::create_dir_all("config")?;
    fs::write(MODEL_CONFIG_PATH, config_content)?;

    Ok(())
}

/// Update the default provider
pub fn update_default_provider(provider_id: &str) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(MODEL_CONFIG_PATH);
    let content = fs::read_to_string(config_path)?;

    let mut result = String::new();

    for line in content.lines() {
        if line.starts_with("default_provider = ") {
            result.push_str(&format!("default_provider = \"{}\"", provider_id));
        } else {
            result.push_str(line);
        }
        result.push('\n');
    }

    fs::write(config_path, result.trim_end())?;
    Ok(())
}

/// Update the default model
pub fn update_default_model(model_name: &str) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(MODEL_CONFIG_PATH);
    let content = fs::read_to_string(config_path)?;

    let mut result = String::new();

    for line in content.lines() {
        if line.starts_with("model = ") {
            result.push_str(&format!("model = \"{}\"", model_name));
        } else {
            result.push_str(line);
        }
        result.push('\n');
    }

    fs::write(config_path, result.trim_end())?;
    Ok(())
}

/// Update the prompt template (legacy compatibility - updates [prompts].template)
pub fn update_prompt_template(template: &str) -> Result<(), Box<dyn Error>> {
    update_prompts_field("template", template, true)
}

/// Update tool_guidance in [prompts] section
pub fn update_tool_guidance(value: &str) -> Result<(), Box<dyn Error>> {
    update_prompts_field("tool_guidance", value, false)
}

/// Update fallback_guidance in [prompts] section
pub fn update_fallback_guidance(value: &str) -> Result<(), Box<dyn Error>> {
    update_prompts_field("fallback_guidance", value, false)
}

/// Update json_retry_message in [prompts] section
pub fn update_json_retry_message(value: &str) -> Result<(), Box<dyn Error>> {
    update_prompts_field("json_retry_message", value, false)
}

/// Update tool_result_instruction in [prompts] section
pub fn update_tool_result_instruction(value: &str) -> Result<(), Box<dyn Error>> {
    update_prompts_field("tool_result_instruction", value, false)
}

/// Generic function to update a field in [prompts] section
fn update_prompts_field(
    field_name: &str,
    value: &str,
    multiline: bool,
) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(MODEL_CONFIG_PATH);
    let content = fs::read_to_string(config_path)?;

    let mut result = String::new();
    let mut in_prompts_section = false;
    let mut field_written = false;
    let mut skip_until_end_quote = false;

    let field_prefix = format!("{} = ", field_name);

    for line in content.lines() {
        // Track if we're in [prompts] section
        if line.trim() == "[prompts]" {
            in_prompts_section = true;
            result.push_str(line);
            result.push('\n');
            continue;
        }

        // Detect new section (not [prompts])
        if line.trim().starts_with('[') && line.trim() != "[prompts]" {
            // If we haven't written the field yet, write it before leaving prompts section
            if in_prompts_section && !field_written {
                if multiline {
                    result.push_str(&format!("{} = \"\"\"\n{}\n\"\"\"\n", field_name, value));
                } else {
                    result.push_str(&format!(
                        "{} = \"{}\"\n",
                        field_name,
                        value.replace('"', "\\\"")
                    ));
                }
                field_written = true;
            }
            in_prompts_section = false;
        }

        // Handle skipping multiline content
        if skip_until_end_quote {
            if line.contains("\"\"\"") {
                skip_until_end_quote = false;
            }
            continue;
        }

        // Check if this line starts the field we want to update
        if in_prompts_section && line.trim().starts_with(&field_prefix) {
            // Write the new value
            if multiline {
                result.push_str(&format!("{} = \"\"\"\n{}\n\"\"\"\n", field_name, value));
            } else {
                result.push_str(&format!(
                    "{} = \"{}\"\n",
                    field_name,
                    value.replace('"', "\\\"")
                ));
            }
            field_written = true;

            // Check if it's a multiline string that we need to skip
            if line.contains("\"\"\"") && line.matches("\"\"\"").count() == 1 {
                skip_until_end_quote = true;
            }
            continue;
        }

        result.push_str(line);
        result.push('\n');
    }

    // If we never found the [prompts] section, add it
    if !field_written {
        if !content.contains("[prompts]") {
            result.push_str("\n[prompts]\n");
        }
        if multiline {
            result.push_str(&format!("{} = \"\"\"\n{}\n\"\"\"\n", field_name, value));
        } else {
            result.push_str(&format!(
                "{} = \"{}\"\n",
                field_name,
                value.replace('"', "\\\"")
            ));
        }
    }

    fs::write(config_path, result.trim_end())?;
    Ok(())
}

/// Sync tools from a server
/// Removes existing tools with the same names before adding new ones
pub fn sync_tools_from_server(
    server_name: &str,
    tools: Vec<(String, String)>,
) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(MODEL_CONFIG_PATH);
    let content = fs::read_to_string(config_path)?;

    // Collect tool names we're about to sync
    let syncing_names: HashSet<&str> = tools.iter().map(|(name, _)| name.as_str()).collect();

    let mut new_content = String::new();
    let mut skip_tool = false;
    let mut pending_header = false;

    for line in content.lines() {
        // Detect start of a new tool block
        if line.trim() == "[[tools]]" {
            // If we were skipping, we're done with that tool
            skip_tool = false;
            pending_header = true;
            continue; // Don't write header yet, wait to check the name
        }

        // Check if this line defines the tool name
        if pending_header {
            if let Some(name) = extract_tool_name(line) {
                // Skip this tool if it has the same name as one we're syncing
                if syncing_names.contains(name.as_str()) {
                    skip_tool = true;
                    pending_header = false;
                    continue;
                }
            }
            // Write the pending header since we're not skipping
            if !skip_tool {
                new_content.push_str("[[tools]]\n");
            }
            pending_header = false;
        }

        if !skip_tool {
            new_content.push_str(line);
            new_content.push('\n');
        }
    }

    // Add new tools from the server
    for (tool_name, description) in tools {
        let escaped_desc = description.replace('\"', "\\\"");
        let tool_block = format!(
            r#"
[[tools]]
name = "{}"
description = "{}"
server = "{}""#,
            tool_name, escaped_desc, server_name
        );
        new_content.push_str(&tool_block);
    }

    fs::write(config_path, new_content.trim_end())?;
    Ok(())
}

/// Extract tool name from a line like `name = "tool_name"`
fn extract_tool_name(line: &str) -> Option<String> {
    let trimmed = line.trim();
    if trimmed.starts_with("name = \"") && trimmed.ends_with("\"") {
        let start = "name = \"".len();
        let end = trimmed.len() - 1;
        Some(trimmed[start..end].to_string())
    } else {
        None
    }
}

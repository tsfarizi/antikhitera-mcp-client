//! Client configuration generator
//!
//! Generates and modifies config/client.toml containing:
//! - `[[providers]]` - API provider configurations
//! - `[[servers]]` - MCP server definitions
//! - `[server]` - REST settings (CORS, docs)

use crate::constants::CONFIG_PATH;
use std::error::Error;
use std::fs;
use std::path::Path;

/// Generate the client configuration file
pub fn generate(
    provider_id: &str,
    provider_type: &str,
    endpoint: &str,
    api_key_env: &str,
    models: &[(String, String)],
) -> Result<(), Box<dyn Error>> {
    let models_toml: String = models
        .iter()
        .map(|(name, display)| {
            format!(
                "    {{ name = \"{}\", display_name = \"{}\" }}",
                name, display
            )
        })
        .collect::<Vec<String>>()
        .join(",\n");

    let config_content = format!(
        r#"# MCP Client Configuration
# Generated by setup wizard

# REST Server Settings
[server]
cors_origins = []

# Providers
[[providers]]
id = "{provider_id}"
type = "{provider_type}"
endpoint = "{endpoint}"
api_key = "{api_key_env}"
models = [
{models_toml}
]
"#,
        provider_id = provider_id,
        provider_type = provider_type,
        endpoint = endpoint,
        api_key_env = api_key_env,
        models_toml = models_toml,
    );

    fs::create_dir_all("config")?;
    fs::write(CONFIG_PATH, config_content)?;

    Ok(())
}

/// Generate the .env file with API keys
pub fn generate_env(api_key_env: &str, api_key: &str) -> Result<(), Box<dyn Error>> {
    let env_path = Path::new("config/.env");

    let content = if env_path.exists() {
        let existing = fs::read_to_string(env_path)?;
        if existing.contains(&format!("{}=", api_key_env)) {
            existing
                .lines()
                .map(|line| {
                    if line.starts_with(&format!("{}=", api_key_env)) {
                        format!("{}={}", api_key_env, api_key)
                    } else {
                        line.to_string()
                    }
                })
                .collect::<Vec<String>>()
                .join("\n")
        } else {
            let suffix = if existing.ends_with('\n') || existing.is_empty() {
                ""
            } else {
                "\n"
            };
            format!("{}{}{}={}\n", existing, suffix, api_key_env, api_key)
        }
    } else {
        format!("{}={}\n", api_key_env, api_key)
    };

    fs::write(env_path, content)?;

    Ok(())
}

/// Add a new provider to the config
pub fn add_provider(
    provider_id: &str,
    provider_type: &str,
    endpoint: &str,
    api_key_env: Option<&str>,
) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(CONFIG_PATH);
    let content = fs::read_to_string(config_path)?;
    let mut new_provider = format!(
        r#"

[[providers]]
id = "{}"
type = "{}"
endpoint = "{}""#,
        provider_id, provider_type, endpoint
    );

    if let Some(key) = api_key_env {
        new_provider.push_str(&format!("\napi_key = \"{}\"", key));
    }
    let updated = format!("{}\n{}", content.trim_end(), new_provider);
    fs::write(config_path, updated)?;

    Ok(())
}

/// Update provider settings in config
pub fn update_provider(
    provider_id: &str,
    new_endpoint: &str,
    new_api_key_env: &str,
) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(CONFIG_PATH);
    let content = fs::read_to_string(config_path)?;
    let mut lines: Vec<String> = content.lines().map(String::from).collect();
    let mut in_target_provider = false;

    for line in &mut lines {
        if line.contains("[[providers]]") {
            in_target_provider = false;
        }
        if line.starts_with(&format!("id = \"{}\"", provider_id)) {
            in_target_provider = true;
        }

        if in_target_provider {
            if line.starts_with("endpoint = ") {
                *line = format!("endpoint = \"{}\"", new_endpoint);
            }
            if line.starts_with("api_key = ") {
                *line = format!("api_key = \"{}\"", new_api_key_env);
            }
        }
    }

    fs::write(config_path, lines.join("\n"))?;
    Ok(())
}

/// Add a model to a provider
pub fn add_model_to_provider(
    provider_id: &str,
    model_name: &str,
    display_name: &str,
) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(CONFIG_PATH);
    let content = fs::read_to_string(config_path)?;
    let new_model = format!(
        "    {{ name = \"{}\", display_name = \"{}\" }}",
        model_name, display_name
    );
    let mut result = String::new();
    let mut in_target_provider = false;
    let mut found_models = false;

    for line in content.lines() {
        if line.contains("[[providers]]") {
            in_target_provider = false;
        }
        if line.contains(&format!("id = \"{}\"", provider_id)) {
            in_target_provider = true;
        }

        if in_target_provider && line.starts_with("models = [") {
            found_models = true;
        }
        if in_target_provider && found_models && line.trim() == "]" {
            result.push_str(",\n");
            result.push_str(&new_model);
            result.push('\n');
            found_models = false;
        }

        result.push_str(line);
        result.push('\n');
    }

    fs::write(config_path, result)?;
    Ok(())
}

/// Remove a model from a provider
pub fn remove_model_from_provider(
    provider_id: &str,
    model_name: &str,
) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(CONFIG_PATH);
    let content = fs::read_to_string(config_path)?;

    let mut result = String::new();
    let mut in_target_provider = false;
    let mut in_models_array = false;

    for line in content.lines() {
        if line.contains("[[providers]]") {
            in_target_provider = false;
            in_models_array = false;
        }
        if line.contains(&format!("id = \"{}\"", provider_id)) {
            in_target_provider = true;
        }
        if in_target_provider && line.starts_with("models = [") {
            in_models_array = true;
        }
        if in_models_array && line.trim() == "]" {
            in_models_array = false;
        }
        if in_models_array && line.contains(&format!("name = \"{}\"", model_name)) {
            continue;
        }

        result.push_str(line);
        result.push('\n');
    }

    fs::write(config_path, result)?;
    Ok(())
}

/// Add a server to the config
pub fn add_server(name: &str, command: &str, args: &[String]) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(CONFIG_PATH);

    if !config_path.exists() {
        return Err("Config file not found. Run setup wizard first.".into());
    }

    let mut content = fs::read_to_string(config_path)?;

    let args_toml = if args.is_empty() {
        String::new()
    } else {
        format!(
            "\nargs = [{}]",
            args.iter()
                .map(|a| format!("\"{}\"", a))
                .collect::<Vec<String>>()
                .join(", ")
        )
    };

    let server_block = format!(
        r#"

[[servers]]
name = "{}"
command = "{}"{}"#,
        name, command, args_toml
    );

    content.push_str(&server_block);
    fs::write(config_path, content)?;

    Ok(())
}

/// Remove a server from the config
pub fn remove_server(server_name: &str) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new(CONFIG_PATH);
    let content = fs::read_to_string(config_path)?;

    let mut result = String::new();
    let mut skip_section = false;
    let mut blank_line_buffer = String::new();

    for line in content.lines() {
        if line.trim() == "[[servers]]" {
            if skip_section {
                skip_section = false;
            }
            blank_line_buffer.clear();
        }
        if line.contains(&format!("name = \"{}\"", server_name)) {
            skip_section = true;
            if result.ends_with("[[servers]]\n") {
                result.truncate(result.len() - "[[servers]]\n".len());
            }
        }
        if line.is_empty() {
            blank_line_buffer.push('\n');
            continue;
        }

        if !skip_section {
            result.push_str(&blank_line_buffer);
            blank_line_buffer.clear();
            result.push_str(line);
            result.push('\n');
        }
    }

    fs::write(config_path, result.trim_end())?;
    Ok(())
}

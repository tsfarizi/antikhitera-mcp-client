//! Configuration file generator

use std::error::Error;
use std::fs;
use std::path::Path;

/// Generate the main TOML config file
pub fn generate_config(
    provider_id: &str,
    provider_type: &str,
    endpoint: &str,
    api_key_env: &str,
    default_model: &str,
    models: &[(String, String)],
) -> Result<(), Box<dyn Error>> {
    let models_toml: String = models
        .iter()
        .map(|(name, display)| {
            format!(
                "    {{ name = \"{}\", display_name = \"{}\" }}",
                name, display
            )
        })
        .collect::<Vec<String>>()
        .join(",\n");

    let config_content = format!(
        r#"# MCP Client Configuration
# Generated by setup wizard

# Default provider and model
default_provider = "{provider_id}"
model = "{default_model}"

# System prompt template
prompt_template = """
You are a helpful AI assistant.

{{{{custom_instruction}}}}

{{{{language_guidance}}}}

{{{{tool_guidance}}}}
"""

# Providers
[[providers]]
id = "{provider_id}"
type = "{provider_type}"
endpoint = "{endpoint}"
api_key = "{api_key_env}"
models = [
{models_toml}
]
"#,
        provider_id = provider_id,
        default_model = default_model,
        provider_type = provider_type,
        endpoint = endpoint,
        api_key_env = api_key_env,
        models_toml = models_toml,
    );

    fs::create_dir_all("config")?;
    fs::write("config/client.toml", config_content)?;

    Ok(())
}

/// Generate the .env file with API keys
pub fn generate_env(api_key_env: &str, api_key: &str) -> Result<(), Box<dyn Error>> {
    let env_path = Path::new("config/.env");

    let content = if env_path.exists() {
        let existing = fs::read_to_string(env_path)?;
        if existing.contains(&format!("{}=", api_key_env)) {
            existing
                .lines()
                .map(|line| {
                    if line.starts_with(&format!("{}=", api_key_env)) {
                        format!("{}={}", api_key_env, api_key)
                    } else {
                        line.to_string()
                    }
                })
                .collect::<Vec<String>>()
                .join("\n")
        } else {
            let suffix = if existing.ends_with('\n') || existing.is_empty() {
                ""
            } else {
                "\n"
            };
            format!("{}{}{}={}\n", existing, suffix, api_key_env, api_key)
        }
    } else {
        format!("{}={}\n", api_key_env, api_key)
    };

    fs::write(env_path, content)?;

    Ok(())
}

/// Add a new provider to the config
pub fn add_provider(
    provider_id: &str,
    provider_type: &str,
    endpoint: &str,
    api_key_env: Option<&str>,
) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new("config/client.toml");
    let content = fs::read_to_string(config_path)?;

    // Build new provider TOML block
    let mut new_provider = format!(
        r#"
[[providers]]
id = "{}"
provider_type = "{}"
endpoint = "{}""#,
        provider_id, provider_type, endpoint
    );

    if let Some(key) = api_key_env {
        new_provider.push_str(&format!("\napi_key = \"{}\"", key));
    }

    // Append to file
    let updated = format!("{}\n{}", content.trim_end(), new_provider);
    fs::write(config_path, updated)?;

    Ok(())
}

/// Update provider settings in config
pub fn update_provider(
    provider_id: &str,
    new_endpoint: &str,
    new_api_key_env: &str,
) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new("config/client.toml");
    let content = fs::read_to_string(config_path)?;

    // Simple regex-free replacement using line-by-line parsing
    let mut lines: Vec<String> = content.lines().map(String::from).collect();
    let mut in_target_provider = false;

    for line in &mut lines {
        // Check if we're entering the target provider section
        if line.contains("[[providers]]") {
            in_target_provider = false;
        }
        if line.starts_with(&format!("id = \"{}\"", provider_id)) {
            in_target_provider = true;
        }

        if in_target_provider {
            if line.starts_with("endpoint = ") {
                *line = format!("endpoint = \"{}\"", new_endpoint);
            }
            if line.starts_with("api_key = ") {
                *line = format!("api_key = \"{}\"", new_api_key_env);
            }
        }
    }

    fs::write(config_path, lines.join("\n"))?;
    Ok(())
}

/// Add a model to a provider
pub fn add_model_to_provider(
    provider_id: &str,
    model_name: &str,
    display_name: &str,
) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new("config/client.toml");
    let content = fs::read_to_string(config_path)?;

    // Find the models array for this provider and add the new model
    let new_model = format!(
        "    {{ name = \"{}\", display_name = \"{}\" }}",
        model_name, display_name
    );

    // Simple approach: find the closing bracket of models array and insert before it
    let mut result = String::new();
    let mut in_target_provider = false;
    let mut found_models = false;

    for line in content.lines() {
        if line.contains("[[providers]]") {
            in_target_provider = false;
        }
        if line.contains(&format!("id = \"{}\"", provider_id)) {
            in_target_provider = true;
        }

        if in_target_provider && line.starts_with("models = [") {
            found_models = true;
        }

        // Insert new model before closing bracket
        if in_target_provider && found_models && line.trim() == "]" {
            result.push_str(",\n");
            result.push_str(&new_model);
            result.push('\n');
            found_models = false;
        }

        result.push_str(line);
        result.push('\n');
    }

    fs::write(config_path, result)?;
    Ok(())
}

/// Remove a model from a provider
pub fn remove_model_from_provider(
    provider_id: &str,
    model_name: &str,
) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new("config/client.toml");
    let content = fs::read_to_string(config_path)?;

    let mut result = String::new();
    let mut in_target_provider = false;
    let mut in_models_array = false;

    for line in content.lines() {
        if line.contains("[[providers]]") {
            in_target_provider = false;
            in_models_array = false;
        }
        if line.contains(&format!("id = \"{}\"", provider_id)) {
            in_target_provider = true;
        }
        if in_target_provider && line.starts_with("models = [") {
            in_models_array = true;
        }
        if in_models_array && line.trim() == "]" {
            in_models_array = false;
        }

        // Skip lines containing the model to remove
        if in_models_array && line.contains(&format!("name = \"{}\"", model_name)) {
            continue;
        }

        result.push_str(line);
        result.push('\n');
    }

    fs::write(config_path, result)?;
    Ok(())
}

/// Add a server to the config
pub fn add_server_to_config(
    name: &str,
    command: &str,
    args: &[String],
) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new("config/client.toml");

    if !config_path.exists() {
        return Err("Config file not found. Run setup wizard first.".into());
    }

    let mut content = fs::read_to_string(config_path)?;

    let args_toml = if args.is_empty() {
        String::new()
    } else {
        format!(
            "\nargs = [{}]",
            args.iter()
                .map(|a| format!("\"{}\"", a))
                .collect::<Vec<String>>()
                .join(", ")
        )
    };

    let server_block = format!(
        r#"

[[servers]]
name = "{}"
command = "{}"{}"#,
        name, command, args_toml
    );

    content.push_str(&server_block);
    fs::write(config_path, content)?;

    Ok(())
}

/// Remove a server from the config
pub fn remove_server_from_config(server_name: &str) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new("config/client.toml");
    let content = fs::read_to_string(config_path)?;

    let mut result = String::new();
    let mut skip_section = false;
    let mut blank_line_buffer = String::new();

    for line in content.lines() {
        // Check if we're starting a new server section
        if line.trim() == "[[servers]]" {
            if skip_section {
                skip_section = false;
            }
            blank_line_buffer.clear();
        }

        // Check if this is the server to remove
        if line.contains(&format!("name = \"{}\"", server_name)) {
            skip_section = true;
            // Remove the [[servers]] line we just added
            if result.ends_with("[[servers]]\n") {
                result.truncate(result.len() - "[[servers]]\n".len());
            }
        }

        // Handle blank lines
        if line.is_empty() {
            blank_line_buffer.push('\n');
            continue;
        }

        if !skip_section {
            result.push_str(&blank_line_buffer);
            blank_line_buffer.clear();
            result.push_str(line);
            result.push('\n');
        }
    }

    fs::write(config_path, result.trim_end())?;
    Ok(())
}

/// Sync tools from a server
pub fn sync_tools_from_server(
    server_name: &str,
    tools: Vec<(String, String)>,
) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new("config/client.toml");
    let mut content = fs::read_to_string(config_path)?;

    // First, remove existing tools for this server
    let mut new_content = String::new();
    let mut skip_tool = false;

    for line in content.lines() {
        if line.trim() == "[[tools]]" {
            skip_tool = false;
        }
        if line.contains(&format!("server = \"{}\"", server_name)) {
            skip_tool = true;
            // Remove the [[tools]] line we just added
            if new_content.ends_with("[[tools]]\n") {
                new_content.truncate(new_content.len() - "[[tools]]\n".len());
            }
        }

        if !skip_tool {
            new_content.push_str(line);
            new_content.push('\n');
        }
    }

    content = new_content;

    // Add new tools
    for (tool_name, description) in tools {
        let escaped_desc = description.replace('\"', "\\\"");
        let tool_block = format!(
            r#"
[[tools]]
name = "{}"
description = "{}"
server = "{}""#,
            tool_name, escaped_desc, server_name
        );
        content.push_str(&tool_block);
    }

    fs::write(config_path, content.trim_end())?;
    Ok(())
}

/// Update the prompt template
pub fn update_prompt_template(template: &str) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new("config/client.toml");
    let content = fs::read_to_string(config_path)?;

    // Find and replace the prompt_template section
    let mut result = String::new();
    let mut in_template = false;
    let mut template_written = false;

    for line in content.lines() {
        if line.starts_with("prompt_template = ") {
            in_template = true;
            if !template_written {
                result.push_str(&format!("prompt_template = \"\"\"\n{}\n\"\"\"\n", template));
                template_written = true;
            }
            // Handle single-line template
            if !line.contains("\"\"\"") {
                in_template = false;
            }
            continue;
        }

        if in_template {
            // Count triple quotes to know when template ends
            if line.contains("\"\"\"") {
                in_template = false;
            }
            continue;
        }

        result.push_str(line);
        result.push('\n');
    }

    fs::write(config_path, result.trim_end())?;
    Ok(())
}

/// Update the default provider
pub fn update_default_provider(provider_id: &str) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new("config/client.toml");
    let content = fs::read_to_string(config_path)?;

    let mut result = String::new();

    for line in content.lines() {
        if line.starts_with("default_provider = ") {
            result.push_str(&format!("default_provider = \"{}\"", provider_id));
        } else {
            result.push_str(line);
        }
        result.push('\n');
    }

    fs::write(config_path, result.trim_end())?;
    Ok(())
}

/// Update the default model
pub fn update_default_model(model_name: &str) -> Result<(), Box<dyn Error>> {
    let config_path = Path::new("config/client.toml");
    let content = fs::read_to_string(config_path)?;

    let mut result = String::new();

    for line in content.lines() {
        if line.starts_with("model = ") {
            result.push_str(&format!("model = \"{}\"", model_name));
        } else {
            result.push_str(line);
        }
        result.push('\n');
    }

    fs::write(config_path, result.trim_end())?;
    Ok(())
}
